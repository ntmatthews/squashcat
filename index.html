<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- ===== Metadata (SEO / Social / App) ===== -->
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SquashCat — Hyperforge Studios (Squash the Cats)</title>
  <meta name="description" content="SquashCat: a fast mini web game by Hyperforge Studios. Jump and stomp cats to rack up a high score in a retro runner vibe." />
  <meta name="author" content="Hyperforge Studios" />
  <meta name="theme-color" content="#111827" />
  <meta name="application-name" content="SquashCat" />
  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="apple-touch-icon" href="apple-touch-icon.png" />
  <link rel="manifest" href="site.webmanifest" />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="SquashCat — Squash the Cats" />
  <meta property="og:description" content="Jump and stomp cats. Simple, fast, and oddly satisfying." />
  <meta property="og:url" content="https://your-domain.example/squashcat" />
  <meta property="og:image" content="https://your-domain.example/og-image.png" />
  <meta property="og:site_name" content="Hyperforge Studios" />

  <!-- Twitter / X Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="SquashCat — Squash the Cats" />
  <meta name="twitter:description" content="Jump and stomp cats for points. Can you beat your best score?" />
  <meta name="twitter:image" content="https://your-domain.example/og-image.png" />
  <meta name="twitter:creator" content="@your_handle" />

  <!-- Optional: build/version placeholder (can be replaced during CI) -->
  <meta name="x-build-version" content="0.1.0" />
  <meta name="x-build-timestamp" content="2025-08-09T00:00:00Z" />

  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "SquashCat",
    "alternateName": "Squash the Cats",
    "author": { "@type": "Organization", "name": "Hyperforge Studios" },
    "publisher": { "@type": "Organization", "name": "Hyperforge Studios" },
    "applicationCategory": "Game",
    "operatingSystem": "Any",
    "gamePlatform": "Web",
    "inLanguage": "en",
    "url": "https://your-domain.example/squashcat",
    "description": "A lightweight browser game where you jump and stomp cats to score points.",
    "genre": ["Arcade", "Casual"],
    "keywords": "game, web game, cats, arcade, jump, stomp",
    "image": "https://your-domain.example/og-image.png"
  }
  </script>
  <!-- ===== End Metadata Section ===== -->

  <style>
    :root{ --bg:#f7f7f7; --foreground:#111827; --muted:#6b7280; }
    html,body{height:100%;}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--foreground);display:flex;align-items:center;justify-content:center;padding:20px}
    .frame{width:min(980px,96vw);background:linear-gradient(180deg,rgba(255,255,255,0.7),rgba(255,255,255,0.55));border-radius:12px;box-shadow:0 12px 30px rgba(2,6,23,0.12);padding:18px;display:flex;flex-direction:column;gap:18px}
    header{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:12px}
    header h1{font-size:16px;margin:0}
    header .meta{font-size:12px;color:var(--muted)}
    .stage{background:linear-gradient(#fff,#f3f4f6);border-radius:8px;padding:10px;display:flex;flex-direction:column;align-items:center}
    canvas{width:100%;height:auto;border-radius:6px;background:transparent}
    .hud{display:flex;gap:12px;align-items:center;width:100%;justify-content:space-between}
    .scorebox{background:rgba(17,24,39,0.04);padding:8px 12px;border-radius:8px;font-weight:700}
    .footer{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--muted);flex-wrap:wrap;gap:8px}
    /* Collapsible metadata panel */
    #metaPanelWrap{font-size:12px;color:var(--muted);background:rgba(17,24,39,0.04);border:1px solid rgba(0,0,0,0.05);padding:10px 12px;border-radius:8px}
    #metaPanelWrap summary{cursor:pointer;list-style:none}
    #metaPanel{margin-top:8px;display:grid;grid-template-columns:auto 1fr;gap:4px 12px}
    #metaPanel div.label{font-weight:600}
    @media (max-width:640px){ .frame{padding:12px} }
  </style>
</head>
<body>
  <div class="frame" role="application" aria-label="ForgeDino Squash by Hyperforge Studios">
    <header>
      <div>
        <h1>Hyperforge Studios — SquashCat (Squash the Cats)</h1>
        <div class="meta">Jump & stomp cats.</div>
      </div>
      <div class="scorebox" id="bestBox">Best: —</div>
    </header>

    <!-- Optional collapsible metadata panel (fill values dynamically if desired) -->
    <details id="metaPanelWrap">
      <summary>Game Metadata</summary>
      <div id="metaPanel">
        <div class="label">Version</div><div id="metaVersion">0.1.0</div>
        <div class="label">Build Time</div><div id="metaBuildTime">2025-08-09T00:00:00Z</div>
        <div class="label">Best Score Stored</div><div id="metaBestScore">—</div>
        <div class="label">Device Pixel Ratio</div><div id="metaDPR">—</div>
        <div class="label">Session Starts</div><div id="metaSessions">—</div>
      </div>
    </details>

    <div class="stage">
      <canvas id="game" width="900" height="200" tabindex="0"></canvas>
      <div class="hud" style="width:100%">
        <div class="controls">Space to jump · Down or S while airborne to stomp · Tap once to jump, tap while airborne to stomp</div>
        <div class="scorebox" id="scoreBox">Squashed: 0</div>
      </div>
    </div>

    <div class="footer">
      <div>Made by Hyperforge Studios</div>
      <div id="status">Ready — press Space to start</div>
    </div>
  </div>

<script>
// ForgeCat — Squash the Cats game code with inline comments for clarity

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Basic dynamic metadata population
(function updateRuntimeMetadata(){
  const metaBestScore = document.getElementById('metaBestScore');
  const metaDPR = document.getElementById('metaDPR');
  const metaSessions = document.getElementById('metaSessions');

  let sessionCount = Number(localStorage.getItem('forge_dino_sessions') || 0);
  sessionCount++;
  localStorage.setItem('forge_dino_sessions', sessionCount);

  metaSessions.textContent = sessionCount;
  metaDPR.textContent = (window.devicePixelRatio || 1).toFixed(2);
})();

// Device Pixel Ratio for crisp rendering on high-DPI screens
let DPR = Math.max(window.devicePixelRatio || 1, 1);

// Resize canvas to match displayed size and DPR
function resize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}

// Initialize canvas size based on window width with limits
function initCanvasSize() {
  const cssWidth = Math.min(900, Math.max(320, window.innerWidth * 0.9));
  canvas.style.width = cssWidth + 'px';
  canvas.style.height = '200px';
  resize();
}
initCanvasSize();

// Update canvas size on window resize
window.addEventListener('resize', () => {
  DPR = Math.max(window.devicePixelRatio || 1, 1);
  initCanvasSize();
});

// Game state variables
let running = false;
let gameOver = false;
let frames = 0;
let score = 0;
let baseSpeed = 2;
let speed = baseSpeed;
let obstacles = [];
let clouds = [];
let particles = [];
let spawnTimer = 0;

// Best score stored in localStorage, if any
let best = JSON.parse(localStorage.getItem('forge_dino_best') || 'null');

// DOM elements for updating UI
const bestBox = document.getElementById('bestBox');
const scoreBox = document.getElementById('scoreBox');
const status = document.getElementById('status');

function updateBestUI() {
  bestBox.textContent = best ? `Best: ${best.score}` : 'Best: —';
  const metaBestScore = document.getElementById('metaBestScore');
  if (metaBestScore) metaBestScore.textContent = best ? best.score : '—';
}
updateBestUI();

// Audio context for simple sound effects
let audioCtx = null;

function ensureAudioCtx() {
  if (!audioCtx) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      audioCtx = null;
    }
  }
}

function playStompSound() {
  ensureAudioCtx();
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  oscillator.type = 'sine';
  oscillator.frequency.setValueAtTime(180, t);
  oscillator.frequency.exponentialRampToValueAtTime(80, t + 0.12);
  gainNode.gain.setValueAtTime(0.0001, t);
  gainNode.gain.exponentialRampToValueAtTime(0.18, t + 0.01);
  gainNode.gain.exponentialRampToValueAtTime(0.0001, t + 0.26);
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  oscillator.start(t);
  oscillator.stop(t + 0.3);
}

function playGameOverSound() {
  ensureAudioCtx();
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  oscillator.type = 'sawtooth';
  oscillator.frequency.setValueAtTime(120, t);
  oscillator.frequency.exponentialRampToValueAtTime(40, t + 0.5);
  gainNode.gain.setValueAtTime(0.0001, t);
  gainNode.gain.exponentialRampToValueAtTime(0.12, t + 0.02);
  gainNode.gain.exponentialRampToValueAtTime(0.0001, t + 0.6);
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  oscillator.start(t);
  oscillator.stop(t + 0.7);
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = -Math.random() * 2 - 0.5;
    this.life = 30 + Math.random() * 20;
    this.size = 2 + Math.random() * 3;
    this.color = `hsla(${Math.floor(10 + Math.random() * 40)},70%,40%,1)`;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.12;
    this.life--;
  }
  draw(ctx) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, this.life / 50);
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.size, this.size);
    ctx.restore();
  }
}

class Dino {
  constructor() {
    this.x = 60;
    this.groundY = 150;
    this.w = 44;
    this.h = 44;
    this.y = this.groundY - this.h;
    this.vy = 0;
    this.gravity = 0.6;
    this.jumpPower = -11;
    this.jumping = false;
    this.ducking = false;
    this.step = 0;
    this.stomping = false;
  }
  jump() {
    if (!this.jumping && !gameOver) {
      this.vy = this.jumpPower;
      this.jumping = true;
      this.stomping = false;
    }
  }
  stomp() {
    if (this.jumping && !this.stomping && !gameOver) {
      this.stomping = true;
      this.vy = 18;
      playStompSound();
    }
  }
  duck(toggle) {
    this.ducking = !!toggle;
    this.h = this.ducking ? 26 : 44;
    if (!this.ducking && this.y > this.groundY - this.h) {
      this.y = this.groundY - this.h;
    }
  }
  update() {
    if (gameOver) return;
    this.vy += this.gravity;
    this.y += this.vy;
    if (this.y >= this.groundY - this.h) {
      this.y = this.groundY - this.h;
      this.vy = 0;
      this.jumping = false;
      this.stomping = false;
    }
    this.step = (this.step + 0.15) % 2;
  }
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = '#111827';
    ctx.fillRect(this.x, this.y, this.w, this.h);
    ctx.fillStyle = '#fff';
    ctx.fillRect(this.x + Math.floor(this.w * 0.65), this.y + 8, 6, 6);
    if (this.stomping) {
      ctx.fillStyle = 'rgba(123,30,30,0.12)';
      ctx.fillRect(this.x - 6, this.y + this.h - 4, this.w + 12, 8);
    }
    ctx.fillStyle = '#0b1220';
    if (!this.jumping) {
      const leg = (this.step < 1) ? 5 : 0;
      ctx.fillRect(this.x + 8, this.y + this.h - 6 + leg, 8, 6);
      ctx.fillRect(this.x + 26, this.y + this.h - 6 - leg, 8, 6);
    } else {
      ctx.fillRect(this.x + 8, this.y + this.h - 6, 8, 6);
      ctx.fillRect(this.x + 26, this.y + this.h - 6, 8, 6);
    }
    ctx.restore();
  }
  bounds() {
    return { x: this.x, y: this.y, w: this.w, h: this.h };
  }
}

class Obstacle {
  constructor(type = 0) {
    this.type = type;
    this.squashed = false;
    this.w = type === 0 ? 22 : (type === 1 ? 36 : 36);
    this.h = type === 0 ? 30 : (type === 1 ? 44 : 28);
    this.x = (canvas.width / DPR) + 10;
    this.y = 150 - this.h;
    this.frame = 0;
    this.removal = 0;
  }
  update() {
    if (gameOver) return;
    this.x -= speed;
    if (this.type === 2) this.frame = (this.frame + 0.3) % 2;
    if (this.squashed) this.removal++;
  }
  draw(ctx) {
    ctx.save();
    if (this.squashed) {
      ctx.fillStyle = '#7b1e1e';
      ctx.fillRect(this.x - 4, this.y + this.h - 10, this.w + 8, 8);
    } else {
      if (this.type === 2) {
        const yy = this.y - 18;
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(this.x, yy, this.w, this.h);
        if (this.frame < 1) {
          ctx.fillRect(this.x + 4, yy - 6, 12, 6);
        } else {
          ctx.fillRect(this.x + 4, yy + this.h - 4, 12, 6);
        }
      } else {
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(this.x, this.y + 6, this.w, this.h - 6);
        ctx.fillRect(this.x + Math.floor(this.w * 0.1), this.y - 6, Math.floor(this.w * 0.6), 12);
        ctx.beginPath();
        ctx.moveTo(this.x + 4, this.y - 6);
        ctx.lineTo(this.x + 8, this.y - 16);
        ctx.lineTo(this.x + 14, this.y - 6);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(this.x + this.w - 14, this.y - 6);
        ctx.lineTo(this.x + this.w - 8, this.y - 16);
        ctx.lineTo(this.x + this.w - 4, this.y - 6);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x + Math.floor(this.w * 0.25), this.y + 8, 4, 4);
        ctx.fillRect(this.x + Math.floor(this.w * 0.6), this.y + 8, 4, 4);
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(this.x + this.w - 6, this.y + 12, 6, 4);
      }
    }
    ctx.restore();
  }
  offscreen() {
    return this.x + this.w < -30 || this.removal > 30;
  }
  bounds() {
    return { x: this.x, y: this.y, w: this.w, h: this.h };
  }
}

class Cloud {
  constructor() {
    this.x = canvas.width / DPR + Math.random() * 200;
    this.y = 20 + Math.random() * 40;
    this.w = 48 + Math.random() * 60;
    this.vx = -(speed * 0.35);
  }
  update() {
    if (gameOver) return;
    this.x += this.vx;
  }
  draw(ctx) {
    ctx.save();
    ctx.fillStyle = '#e6eef7';
    ctx.fillRect(this.x, this.y, this.w, 16);
    ctx.fillRect(this.x - 12, this.y + 4, 28, 10);
    ctx.restore();
  }
}

const dino = new Dino();

function spawnObstacle() {
  const r = Math.random();
  let type = r < 0.7 ? 0 : (r < 0.95 ? 1 : 2);
  obstacles.push(new Obstacle(type));
}
function spawnCloud() {
  clouds.push(new Cloud());
}
function rectsIntersect(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function resetGame() {
  running = false;
  gameOver = false;
  frames = 0;
  score = 0;
  speed = baseSpeed;
  obstacles = [];
  clouds = [];
  particles = [];
  spawnTimer = 0;
  dino.y = dino.groundY - dino.h;
  dino.vy = 0;
  dino.jumping = false;
  dino.stomping = false;
  status.textContent = 'Ready — press Space to start';
  updateScoreUI();
}
resetGame();

function updateScoreUI() {
  scoreBox.textContent = `Squashed: ${score}`;
}

function skyGradient(t) {
  const p = 40;
  const phase = -Math.PI / 2;
  const a = (Math.sin((t / p) * Math.PI * 2 + phase) + 1) / 2;
  const dayTop = [255, 255, 255];
  const dayBot = [238, 243, 255];
  const nightTop = [18, 24, 49];
  const nightBot = [8, 12, 28];
  function lerp(c0, c1, a) {
    return c0.map((v, i) => Math.round(v * (1 - a) + c1[i] * a));
  }
  const top = lerp(dayTop, nightTop, a);
  const bot = lerp(dayBot, nightBot, a);
  return { top: `rgb(${top.join(',')})`, bot: `rgb(${bot.join(',')})`, nightAlpha: a };
}

function gameLoop() {
  if (running && !gameOver) frames++;
  const t = frames / 60;
  const cw = canvas.width / DPR;
  const ch = canvas.height / DPR;

  const sky = skyGradient(t);
  const gradient = ctx.createLinearGradient(0, 0, 0, ch);
  gradient.addColorStop(0, sky.top);
  gradient.addColorStop(1, sky.bot);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, cw, ch);

  const nightAlpha = sky.nightAlpha;
  const sunX = (cw * 0.8) - Math.sin(t / 6) * 60;
  const sunY = 36 + Math.cos(t / 6) * 12;

  ctx.save();
  ctx.globalAlpha = 1 - nightAlpha;
  ctx.beginPath();
  ctx.fillStyle = '#ffd166';
  ctx.arc(sunX, sunY, 18, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.globalAlpha = nightAlpha;
  ctx.beginPath();
  ctx.fillStyle = '#e6eef7';
  ctx.arc(sunX - 10, sunY + 6, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  if (running && !gameOver && frames % 160 === 0) spawnCloud();

  clouds.forEach((c, i) => {
    c.draw(ctx);
    if (!gameOver) c.update();
    if (c.x + c.w < -50) clouds.splice(i, 1);
  });

  ctx.fillStyle = nightAlpha > 0.5 ? '#0b1220' : '#111827';
  ctx.fillRect(0, 150, cw, 4);
  ctx.fillStyle = nightAlpha > 0.5 ? '#1f2937' : '#cbd5e1';
  for (let x = 0; x < cw; x += 12) {
    ctx.fillRect(x, 154, 6, 2);
  }

  if (running && !gameOver) {
    spawnTimer -= 1;
    if (spawnTimer <= 0) {
      spawnTimer = 140 + Math.random() * 120 - Math.min(60, Math.floor(score / 3));
      spawnObstacle();
    }
    speed = baseSpeed + Math.floor(score / 10);
  }

  obstacles.forEach((o, i) => {
    o.draw(ctx);
    if (!gameOver) o.update();
    if (o.offscreen()) obstacles.splice(i, 1);
  });

  particles.forEach((p, i) => {
    p.update();
    p.draw(ctx);
    if (p.life <= 0) particles.splice(i, 1);
  });

  dino.draw(ctx);
  if (running && !gameOver) dino.update();

  if (running && !gameOver) {
    for (const o of obstacles) {
      if (o.squashed) continue;
      if (rectsIntersect(dino.bounds(), o.bounds())) {
        if (dino.stomping) {
          o.squashed = true;
            o.removal = 0;
            dino.vy = -8;
            dino.stomping = false;
            score++;
            updateScoreUI();
            playStompSound();
            const px = o.x + o.w / 2;
            const py = o.y + o.h / 2;
            for (let n = 0; n < 18; n++) {
              particles.push(new Particle(px + (Math.random() - 0.5) * 10, py + (Math.random() - 0.5) * 6));
            }
            if (!best || score > best.score) {
              best = { score, when: new Date().toISOString() };
              localStorage.setItem('forge_dino_best', JSON.stringify(best));
              updateBestUI();
            }
        } else {
          gameOver = true;
          running = false;
          status.textContent = 'Game Over — press Space to restart';
          playGameOverSound();
          break;
        }
      }
    }
  }

  if (!running && !gameOver) {
    ctx.save();
    ctx.fillStyle = nightAlpha > 0.5 ? '#f3f4f6' : '#111827';
    ctx.font = '14px Inter,Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Press Space or Tap to start — stomp cats to score (tap while airborne to stomp)', cw / 2, 90);
    ctx.restore();
  }

  if (gameOver) {
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fillRect(0, 0, cw, ch);
    ctx.fillStyle = '#111827';
    ctx.font = '18px Inter,Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', cw / 2, ch / 2 - 10);
    ctx.font = '14px Inter,Arial';
    ctx.fillText('Press Space or Tap to restart', cw / 2, ch / 2 + 14);
    ctx.restore();
  }

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

function startIfNeeded() {
  if (!running && !gameOver) {
    running = true;
    status.textContent = 'Playing';
  }
}

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w') {
    e.preventDefault();
    if (gameOver) {
      resetGame();
      startIfNeeded();
    }
    startIfNeeded();
    dino.jump();
  }
  if (e.code === 'ArrowDown' || e.key === 's') {
    e.preventDefault();
    if (dino.jumping) dino.stomp();
    else dino.duck(true);
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'ArrowDown' || e.key === 's') {
    if (!dino.jumping) dino.duck(false);
  }
});

canvas.addEventListener('pointerdown', (ev) => {
  if (gameOver) {
    resetGame();
    startIfNeeded();
  }
  startIfNeeded();
  if (dino.jumping) dino.stomp();
  else dino.jump();
});

canvas.addEventListener('click', () => canvas.focus());

for (let i = 0; i < 2; i++) clouds.push(new Cloud());

window.ForgeDino = {
  reset: resetGame,
  start: () => {
    running = true;
    status.textContent = 'Playing';
  },
  getScore: () => score,
};
</script>
</body>
</html>
